---
title: "Report"
author: 
  name: "Coordenação de Indicadores Sociais (CIS)"
  url: https://imrs.fjp.mg.gov.br/
output: html_document
date: "`r Sys.Date()`"
params:
  data: file.xlsx
  metadata: metafile.xlsx
---

```{r setup, include=FALSE}
#library(openxlsx)
#library(validate)

knitr::opts_chunk$set(echo = TRUE)
#Read dataset
data <- openxlsx::read.xlsx(params$data)
#Read dataset documentation
metadata <- openxlsx::read.xlsx(params$metadata)
data <- data %>%  
  dplyr::select(-c("CHAVE", "IBGE6"))


```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.


```{r include=FALSE}
#take all variables
colunm_meta <- metadata %>% 
  dplyr::filter(`DIMENSÃO` != "atlas") %>% 
  dplyr::pull(SIGLA)

#take all categorical variables
categorical_variable <- metadata %>% 
  dplyr::filter(`DIMENSÃO` != "atlas" & UNIDADE == "Sim/Não") %>% 
  dplyr::pull(SIGLA)

text_variable <- metadata %>% 
  dplyr::filter(`DIMENSÃO` != "atlas" & is.na(UNIDADE)) %>%   
  dplyr::pull(SIGLA)

#quantitative variable

numeric_variable <- colunm_meta[!(colunm_meta %in% c(categorical_variable,text_variable)) ] 

```

```{r include=FALSE}
data$ANO <- as.character(data$ANO)
yearbase <- max(data$ANO, na.rm = TRUE)
yearstart <- min(data$ANO, na.rm = TRUE)
n_city <- 853
n_years <- length(unique(data$ANO))
name_dimension <- tail(metadata$DIMENSÃO,1)
```

# IMRS - Dimensão `r tools::toTitleCase(name_dimension)`

1.  A base de dados do IMRS da dimensão `r tools::toTitleCase(name_dimension)` `r if(nrow(data) == n_city * n_years) {" possui"} else {" não possui"}` o total esperado de observações. Vale ressaltar que a base de `r yearbase` deve possuir `r n_city*n_years` observações.

2.  A base de dados da dimensão `r tools::toTitleCase(name_dimension)` possui `r length(colunm_meta)` variáveis excluindo CHAVE, IBGE6, IBGE7 e ANO.

3.  Destas `r length(colunm_meta)` variáveis, `r length(numeric_variable)` são numéricas, `r length(text_variable)` `r if(length(text_variable) > 1) {" textuais"} else {" textual"}` e `r length(categorical_variable)` `r if(length(categorical_variable) > 1) {" booleanas"} else {" booleana"}`.


# Tabelas e Gráficos
```{r echo=FALSE}
statistics <- data %>% 
  dplyr::select(c(IBGE7,ANO,all_of(numeric_variable))) %>% 
  tidyr::pivot_longer(!c(IBGE7,ANO), names_to = "variable", values_to = "value") %>%
  dplyr::group_by(ANO, variable) %>%
  dplyr::summarise(n_obs = dplyr::n(),
                   minimo = min(value, na.rm = TRUE),
                   q1 = quantile(value, probs = 0.25, na.rm = TRUE),
                   media = mean(value, na.rm = TRUE),
                   mediana = median(value, na.rm = TRUE),
                   q3 = quantile(value, probs = 0.75, na.rm = TRUE),
                   maximo = max(value, na.rm = TRUE),
                   desvio_padrao = sd(value, na.rm = TRUE),
                   n_zero = sum(value == 0, na.rm = TRUE),
                   ausentes = sum(is.na(value), na.rm = TRUE)) %>% 
  dplyr::ungroup() 

res <- split(statistics, f = statistics$variable)
# dd <- data %>% 
#   dplyr::group_by(ANO) %>% 
#   dplyr::summarise(dplyr::across(numeric_variable,
#                    list(n_obs = ~dplyr::n(), minimo = ~min(.,na.rm = TRUE), media =  ~mean(., na.rm = TRUE), maximo = ~max(.,na.rm = TRUE) ) ) ) %>% 
#   dplyr::ungroup()
statistics %>% dplyr::arrange(variable)
```




```{r echo=FALSE, include=FALSE}
# Definir funções ---------------------------------------------------------

## https://blogs.sas.com/content/iml/2021/06/01/hampel-filter-robust-outliers.html
hampel_filter <- function(var){
  limite_inf <- median(var, na.rm = T) - 3 * mad(var, constant = 1, na.rm = T)
  limite_sup <- median(var, na.rm = T) + 3 * mad(var, constant = 1, na.rm = T)
  result <- (var < limite_inf | var > limite_sup)
  return(result)
}


# Definir regras ----------------------------------------------------------

## Categorias L_ORGESP
categ_orgaogestor <- c(
  "Outros",                                               
  "Secretaria municipal exclusiva",                       
  "Não possui estrutura",                                 
  "Secretaria em conjunto com outras políticas setoriais",
  "Secretaria exclusiva",                                 
  "Setor subordinado a outra secretaria",                 
  "Setor subordinado diretamente  à chefia do Executivo", 
  "Órgão da administração indireta"    
)

## Regras

### Tipo
regra_tipo <- validate::validator(
  TI_L_EQUI    = is.character(L_EQUI),
  TI_L_QUANT   = is.numeric(L_QUANT),
  TI_L_PARTESP = is.character(L_PARTESP),
  TI_L_PROGE   = is.numeric(L_PROGE),
  TI_L_ESPESC  = is.numeric(L_ESPESC),
  TI_L_ILRHE   = is.numeric(L_ILRHE),
  TI_L_CONSESP = is.character(L_CONSESP),
  TI_L_ORGESP  = is.character(L_ORGESP),
  TI_L_CONVESP = is.character(L_CONVESP)
)

### Validade
regra_validade <- validate::validator(
  VI_GERAL     = is_unique(ANO, IBGE7),
  VI_L_EQUI    = L_EQUI %in% c("Sim", "Não"),
  VI_L_QUANT   = L_QUANT >= 0,
  VI_L_PARTESP = L_PARTESP %in% c("Sim", "Não"),
  VI_L_PROGE   = L_PROGE >= 0,
  VI_L_ESPESC  = in_range(L_ESPESC, min = 0, max = 100),
  VI_L_ILRHE   = in_range(L_ILRHE, min = 0, max = 100),
  VI_L_CONSESP = L_CONSESP %in% c("Sim", "Não"),
  VI_L_ORGESP  = L_ORGESP %in% categ_orgaogestor,
  VI_L_CONVESP = L_CONVESP %in% c("Sim", "Não")
)

### Consistência (TVL: Transversal/LGT: Longitudinal)
regra_consistencia <- validate::validator(
  CF_TVL_L_QUANT_A  = validate::do_by(L_QUANT, by = ANO, fun = hampel_filter) == FALSE, # Comparação por ano
  CF_LGT_L_QUANT_A  = validate::do_by(L_QUANT, by = IBGE7, fun = hampel_filter) == FALSE, # Comparação por município
  CF_TVL_L_QUANT_B  = L_QUANT <= (2 * validate::do_by(L_QUANT, by = ANO, fun = mean, na.rm = T)),
  CF_LGT_L_QUANT_B  = L_QUANT <= (2 * validate::do_by(L_QUANT, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right")),
  CF_TVL_L_PROGE_A  = validate::do_by(L_PROGE, by = IBGE7, fun = hampel_filter) == FALSE,
  CF_LGT_L_PROGE_A  = validate::do_by(L_PROGE, by = ANO, fun = hampel_filter) == FALSE,
  CF_TVL_L_PROGE_B  = L_PROGE <= (2 * validate::do_by(L_PROGE, by = ANO, fun = mean, na.rm = T)),
  CF_LGT_L_PROGE_B  = L_PROGE <= (2 * validate::do_by(L_PROGE, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right")),
  CF_TVL_L_ESPESC_A = validate::do_by(L_ESPESC, by = IBGE7, fun = hampel_filter) == FALSE,
  CF_LGT_L_ESPESC_A = validate::do_by(L_ESPESC, by = ANO, fun = hampel_filter) == FALSE,
  CF_TVL_L_ESPESC_B = L_ESPESC <= (2 * validate::do_by(L_ESPESC, by = ANO, fun = mean, na.rm = T)),
  CF_LGT_L_ESPESC_B = L_ESPESC <= (2 * validate::do_by(L_ESPESC, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right")),
  CF_TVL_L_ILRHE_A  = validate::do_by(L_ILRHE, by = IBGE7, fun = hampel_filter) == FALSE,
  CF_LGT_L_ILRHE_A  = validate::do_by(L_ILRHE, by = ANO, fun = hampel_filter) == FALSE,
  CF_TVL_L_ILRHE_B  = L_ILRHE <= (2 * validate::do_by(L_ILRHE, by = ANO, fun = mean, na.rm = T)),
  CF_LGT_L_ILRHE_B  = L_ILRHE <= (2 * validate::do_by(L_ILRHE, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right"))
)


```

## Checando as regras de tipo
```{r echo=FALSE}
check_tipo <- validate::confront(data, regra_tipo)

```

## Checando as regras de validade
```{r echo=FALSE}
check_validade <- validate::confront(data, regra_validade)

```

## Checando as regras de consistência
```{r echo=FALSE, eval=FALSE}
check_consistencia <- validate::confront(data, regra_consistencia)

```

## Resumo da regra de tipo

```{r echo=FALSE, eval=FALSE}
summary(check_tipo)
```

## Resumo da regra de validade
```{r echo=FALSE, eval=FALSE}
summary(check_validade)
```

## Resumo da regra de consistência
```{r echo=FALSE, eval=FALSE}
summary(check_consistencia)
```


## Gráfico para regra de tipo 
```{r eval=FALSE, include=FALSE}
plot(check_tipo)
```

## Gráfico para regra de validade
```{r eval=FALSE,include=FALSE}
plot(check_validade)
```

## Gráfico para regra de consistência
```{r eval=FALSE, include=FALSE}
plot(check_consistencia)
```

