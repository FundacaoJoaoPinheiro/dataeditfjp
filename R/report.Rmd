---
title: "Report"
author: 
  name: "Coordenação de Indicadores Sociais (CIS)"
  url: https://imrs.fjp.mg.gov.br/
output: html_document
date: "`r Sys.Date()`"
params:
  data: file.xlsx
  metadata: metafile.xlsx
---

```{r setup, include=FALSE}
#library(openxlsx)
#library(validate)
options(dplyr.summarise.inform = FALSE)
knitr::opts_chunk$set(echo = TRUE)
#Read dataset
data <- openxlsx::read.xlsx(params$data)
#Read dataset documentation
metadata <- openxlsx::read.xlsx(params$metadata)
data <- data %>%  
  dplyr::select(-c("CHAVE", "IBGE6"))


```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.


```{r include=FALSE}
#take all variables
colunm_meta <- metadata %>% 
  dplyr::filter(`DIMENSÃO` != "atlas") %>% 
  dplyr::pull(SIGLA)

#take all categorical variables
categorical_variable <- metadata %>% 
  dplyr::filter(`DIMENSÃO` != "atlas" & UNIDADE == "Sim/Não") %>% 
  dplyr::pull(SIGLA)

text_variable <- metadata %>% 
  dplyr::filter(`DIMENSÃO` != "atlas" & is.na(UNIDADE)) %>%   
  dplyr::pull(SIGLA)

#quantitative variable

numeric_variable <- colunm_meta[!(colunm_meta %in% c(categorical_variable,text_variable)) ] 

```

```{r include=FALSE}
data$ANO <- as.character(data$ANO)
yearbase <- max(data$ANO, na.rm = TRUE)
yearstart <- min(data$ANO, na.rm = TRUE)
n_city <- 853
n_years <- length(unique(data$ANO))
name_dimension <- tail(metadata$DIMENSÃO,1)
```

# IMRS - Dimensão `r tools::toTitleCase(name_dimension)`

1.  A base de dados do IMRS da dimensão `r tools::toTitleCase(name_dimension)` `r if(nrow(data) == n_city * n_years) {" possui"} else {" não possui"}` o total esperado de observações. Vale ressaltar que a base de `r yearbase` deve possuir `r n_city*n_years` observações.

2.  A base de dados da dimensão `r tools::toTitleCase(name_dimension)` possui `r length(colunm_meta)` variáveis excluindo CHAVE, IBGE6, IBGE7 e ANO.

3.  Destas `r length(colunm_meta)` variáveis, `r length(numeric_variable)` são numéricas, `r length(text_variable)` `r if(length(text_variable) > 1) {" textuais"} else {" textual"}` e `r length(categorical_variable)` `r if(length(categorical_variable) > 1) {" booleanas"} else {" booleana"}`.


# Descriptive Analysis
```{r echo=FALSE, warning=FALSE}

statistics <- data %>% 
  dplyr::select(c(IBGE7,ANO,all_of(numeric_variable))) %>% 
  tidyr::pivot_longer(!c(IBGE7,ANO), names_to = "variable", values_to = "value") %>%
  dplyr::group_by(ANO, variable) %>%
  dplyr::summarise(n_obs = dplyr::n(),
                   minimo = min(value),
                   q1 = quantile(value, probs = 0.25, na.rm = TRUE),
                   media = mean(value, na.rm = TRUE),
                   mediana = median(value, na.rm = TRUE),
                   q3 = quantile(value, probs = 0.75, na.rm = TRUE),
                   maximo = max(value),
                   desvio_padrao = sd(value, na.rm = TRUE),
                   n_zero = sum(value == 0, na.rm = TRUE),
                   ausentes = sum(is.na(value), na.rm = TRUE)) %>% 
  dplyr::ungroup() 

res <- split(statistics, f = statistics$variable)
# dd <- data %>% 
#   dplyr::group_by(ANO) %>% 
#   dplyr::summarise(dplyr::across(numeric_variable,
#                    list(n_obs = ~dplyr::n(), minimo = ~min(.,na.rm = TRUE), media =  ~mean(., na.rm = TRUE), maximo = ~max(.,na.rm = TRUE) ) ) ) %>% 
#   dplyr::ungroup()

names(res) %>% 
  sapply(function(i){
    pander::pandoc.header(i, level = 2)
    pander::pandoc.table(res[[i]], decimal.mark = ",", big.mark = ".", round = 2, caption = metadata$DENOMINAÇÃO[which(metadata$SIGLA == i)] )
    cat("\n")
  })
```

# Charts

```{r echo=FALSE, include=FALSE, warning=FALSE}

list_data <- data %>% 
  dplyr::select(c(IBGE7,ANO,all_of(numeric_variable))) %>% 
  tidyr::pivot_longer(!c(IBGE7,ANO), names_to = "variable", values_to = "value") 

list_data <- split(list_data, f = list_data$variable)

graphic <- names(list_data) %>% 
  sapply(function(i){
    graf <- list_data[[i]] %>% 
      ggplot2::ggplot( ) +
      ggplot2::geom_boxplot(mapping=ggplot2::aes(x = ANO, y = value)) +
      ggplot2::ylab(i)
    return(graf)
  },simplify = F,USE.NAMES = T)

```

```{r echo=FALSE, warning=FALSE}
names(graphic) %>% 
  sapply(function(i){
    return(show(graphic[[i]]))
  },simplify = F, USE.NAMES = TRUE)

```


```{r echo=FALSE, warning=FALSE}
# Definir funções ---------------------------------------------------------

## https://blogs.sas.com/content/iml/2021/06/01/hampel-filter-robust-outliers.html
hampel_filter <- function(var){
  limite_inf <- median(var, na.rm = T) - 3 * mad(var, constant = 1, na.rm = T)
  limite_sup <- median(var, na.rm = T) + 3 * mad(var, constant = 1, na.rm = T)
  result <- (var < limite_inf | var > limite_sup)
  return(result)
}


# Definir regras ----------------------------------------------------------

## Regras para tema meio ambiente

var_amb <- c("ANO", "IBGE7", "M_AGRO", "M_AIIGENA", "M_BOVINO", "M_CANA" , "M_CFEM" , "M_COMITE", "M_CRH", "M_FLONATIVA" , "M_FMMA", "M_FOCOS", "M_FROTA", "M_ICMSECOLOG", "M_INFRA", "M_LEGISL", "M_MATLANTICA", "M_OGESTOR", "M_PROINTEGRAL", "M_REFLO", "M_USOSUST") 


if(sum(var_amb %in% names(data)) != 0){
  org_gestor <- c("Departamento, assessoria, setor ou órgão similar",
                  "Secretaria municipal em conjunto com outros temas",    
                  "Não possui estrutura para a área",   
                  "Secretaria municipal exclusiva",                    
                   "Setor subordinado a outra secretaria",                 
                  "Secretaria em conjunto com outra política",            
                   "Não possui estrutura",            
                   "Setor subordinado diretamente à chefia do executivo",  
                   "Secretaria exclusiva",                                
                   "Órgão da administração indireta",  
                   "Secretaria municipal em conjunto com outras políticas",
                   "Setor subordinado diretamente à chefia do Executivo",
                   "Secretaria em conjunto com outras políticas setoriais")
  
  #typerules <- validate::validator(.file = "typerules_meio_ambiente.R")
  typerules <-  validate::validator(
    TI_M_AGRO = is.numeric(M_AGRO),
    TI_M_AIIGENA = is.numeric(M_AIIGENA),
    TI_M_BOVINO = is.numeric(M_BOVINO),
    TI_M_CANA = is.numeric(M_CANA),
    TI_M_CFEM = is.numeric(M_CFEM),
    TI_M_COMITE = is.character(M_COMITE),
    TI_M_CRH = is.numeric(M_CRH),
    TI_M_FLONATI_M_VA = is.numeric(M_FLONATI_M_VA),
    TI_M_FMMA = is.character(M_FMMA),
    TI_M_FOCOS = is.numeric(M_FOCOS),
    TI_M_FROTA = is.numeric(M_FROTA),
    TI_M_ICMSECOLOG = is.numeric(M_ICMSECOLOG),
    TI_M_INFRA = is.numeric(M_INFRA),
    TI_M_LEGISL = is.character(M_LEGISL),
    TI_M_MATLANTICA = is.numeric(M_MATLANTICA),
    TI_M_OGESTOR = is.character(M_OGESTOR),
    TI_M_PROINTEGRAL = is.numeric(M_PROINTEGRAL),
    TI_M_REFLO = is.numeric(M_REFLO),
    TI_M_USOSUST = is.numeric(M_USOSUST)
  )
  
  validaterules <-  validate::validator(
    VI_GERAL = validate::is_unique(ANO,IBGE7),
    VI_M_AGRO = validate::in_range(M_AGRO, min = 0, max = 100),
    VI_M_AIIGENA = validate::in_range(M_AIIGENA, min = 0, max = 100),
    VI_M_BOVINO = M_BOVINO>=0,
    VI_M_CANA = validate::in_range(M_CANA, min = 0, max = 100),
    VI_M_CFEM = M_CFEM >=0,
    VI_M_COMITE = M_COMITE %in% c("Sim", "Não"),
    VI_M_CRH = M_CRH >= 0,
    VI_M_FLONAVI_M_VA = validate::in_range(M_FLONAVI_M_VA, min = 0, max = 100),
    VI_M_FMMA = M_FMMA %in% c("Sim", "Não"),
    VI_M_FOCOS = validate::in_range(M_FOCOS, min = 0, max = 100),
    VI_M_FROTA = M_FROTA >= 0,
    VI_M_ICMSECOLOG = M_ICMSECOLOG >= 0,
    VI_M_INFRA = validate::in_range(M_IFRA, min = 0, max = 100),
    VI_M_LEGISL = M_LEGISL %in% c("Sim", "Não"),
    VI_M_MATLANTICA = validate::in_range(M_MATLANTICA, min = 0, max = 100),
    VI_M_OGESTOR = M_OGESTOR %in% org_gestor,
    VI_M_PROINTEGRAL = validate::in_range(M_PROINTEGRAL, min = 0, max = 100),
    VI_M_REFLO = validate::in_range(M_REFLO, min = 0, max = 100),
    VI_M_USOSUST = validate::in_range(M_USOSUST, min = 0, max = 100)
  )
  
}




# ### Consistência (TVL: Transversal/LGT: Longitudinal)
# regra_consistencia <- validate::validator(
#   CF_TVL_L_QUANT_A  = validate::do_by(L_QUANT, by = ANO, fun = hampel_filter) == FALSE, # Comparação por ano
#   CF_LGT_L_QUANT_A  = validate::do_by(L_QUANT, by = IBGE7, fun = hampel_filter) == FALSE, # Comparação por município
#   CF_TVL_L_QUANT_B  = L_QUANT <= (2 * validate::do_by(L_QUANT, by = ANO, fun = mean, na.rm = T)),
#   CF_LGT_L_QUANT_B  = L_QUANT <= (2 * validate::do_by(L_QUANT, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right")),
#   CF_TVL_L_PROGE_A  = validate::do_by(L_PROGE, by = IBGE7, fun = hampel_filter) == FALSE,
#   CF_LGT_L_PROGE_A  = validate::do_by(L_PROGE, by = ANO, fun = hampel_filter) == FALSE,
#   CF_TVL_L_PROGE_B  = L_PROGE <= (2 * validate::do_by(L_PROGE, by = ANO, fun = mean, na.rm = T)),
#   CF_LGT_L_PROGE_B  = L_PROGE <= (2 * validate::do_by(L_PROGE, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right")),
#   CF_TVL_L_ESPESC_A = validate::do_by(L_ESPESC, by = IBGE7, fun = hampel_filter) == FALSE,
#   CF_LGT_L_ESPESC_A = validate::do_by(L_ESPESC, by = ANO, fun = hampel_filter) == FALSE,
#   CF_TVL_L_ESPESC_B = L_ESPESC <= (2 * validate::do_by(L_ESPESC, by = ANO, fun = mean, na.rm = T)),
#   CF_LGT_L_ESPESC_B = L_ESPESC <= (2 * validate::do_by(L_ESPESC, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right")),
#   CF_TVL_L_ILRHE_A  = validate::do_by(L_ILRHE, by = IBGE7, fun = hampel_filter) == FALSE,
#   CF_LGT_L_ILRHE_A  = validate::do_by(L_ILRHE, by = ANO, fun = hampel_filter) == FALSE,
#   CF_TVL_L_ILRHE_B  = L_ILRHE <= (2 * validate::do_by(L_ILRHE, by = ANO, fun = mean, na.rm = T)),
#   CF_LGT_L_ILRHE_B  = L_ILRHE <= (2 * validate::do_by(L_ILRHE, by = IBGE7, fun = rollmean, k = 3, fill = NA, align = "right"))
# )


```


## Checando as regras de tipo

```{r echo=FALSE, warning=FALSE, message=FALSE}

check_type <- validate::confront(data, typerules)

validate::summary(check_type)
```

## Checando as regras de validade
```{r echo=FALSE, warning=FALSE, message=FALSE}

check_validate <- validate::confront(data, validaterules)

validate::summary(check_validate)
```

## Checando as regras de consistência
```{r echo=FALSE, eval=FALSE}

check_consistencia <- validate::confront(data, regra_consistencia)

```



## Gráfico para regra de tipo 
```{r echo=FALSE}
validate::plot(check_type)
```

## Gráfico para regra de validade
```{r echo=FALSE}
validate::plot(check_validate)
```

## Gráfico para regra de consistência
```{r eval=FALSE, include=FALSE}
plot(check_consistencia)
```

